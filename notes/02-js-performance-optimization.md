> Part 1- JavaScript 深度剖析
>
> Mod 2 - 函数式编程与 JavaScript 性能优化
>
> 本模块带你学习时下前端最主流的函数式编程范式，彻底解决代码重用，以及一些常见的函数式编程库的使用和原理；同时我们还会学习 JavaScript 性能优化的常用方案，深入学习 JavaScript 垃圾回收的机制，以及 Chrome 中的性能调试工具 Performance 的使用。



# Task 2 - JavaScript 性能优化



## 概述

+ 性能优化是不可避免的
+ 哪些内容可以看作是性能优化
+ 无处不在的前端性能优化

本阶段的核心是 JavaScript 语言的优化



## 内容概要

+ 内存管理
+ 垃圾回收与常见 GC 算法
+ V8 引擎的垃圾回收
+ Performance 工具
+ 代码优化实例



## 内存管理

> Memory Management



### 介绍

+ 内存：由可读写单元组成，表示一片可操作空间
+ 管理：人为的区操作一片空间的申请、使用和释放
+ 内存管理：开发者主动申请空间、使用空间、释放空间
+ 管理流程：申请-使用-释放



### JS 中的内存管理

+ 申请内存空间
+ 使用内存空间
+ 释放内存空间



## 垃圾回收

+ JavaScript 中的内存管理是自动的
+ 对象不再**被引用**时是垃圾
+ 对象不能**从根上访问**到时是垃圾



JavaScript 中的可达对象

+ 可以访问到的对象就是可达对象（引用、作用域链）
+ 可达的标准就是从根出发是否能够被找到
+ JavaScript 中的根就可以理解为是全局变量对象



## GC 算法

GC 定义与作用

+ GC 就是垃圾回收机制的简写
+ GC 可以找到内存中的垃圾、并释放和回收空间



GC 里的垃圾是什么

+ 程序中不再需要使用的对象

  ```js
  function func () {
    name = 'lg'
    return `${name} is a coder`
  }
  func()
  ```

  ```js
  function func () {
    const name = 'lg'
    return `${name} is a coder`
  }
  func()
  ```



GC 算法

+ GC 是一种机制，垃圾回收器完成具体的工作
+ 工作的内容就是查找垃圾释放空间、回收空间
+ 算法就是工作时查找和回收所遵循的规则



常见 GC 算法

+ 引用计数
+ 标记清除
+ 标记整理
+ 分代回收



### 引用计数算法

#### 基本原理

+ 核心思想：设置引用数，判断当前引用数是否为 0
+ 引用计数器
+ 引用关系改变时修改引用数字
+ 引用数字为 0 时立即回收



#### 优点

+ 发现垃圾时立即回收
+ 最大限度减少程序暂停



#### 缺点

+ 无法回收循环引用的对象
+ 时间开销大



### 标记清除算法

#### 基本原理

+ 核心思想：分标记和清除两个阶段完成
+ 遍历所有对象找标记活动对象
+ 遍历所有对象清除没有标记对象
+ 回收相应的空间



#### 优点

+ 相对与引用计数算法，可以解决循环引用对象的回收问题



缺点

+ 会造成空间的碎片化，碎片过多会导致如果有较大的对象需要空间，可能无法找到这样的空间。



### 标记整理算法

#### 基本原理

+ 标记整理可以看作时标记清除的增强
+ 标记阶段的操作和标记清除一致
+ 清除阶段会先执行整理，移动对象位置



### 常见 GC 算法总结

+ 引用计数
  + 可以及时回收垃圾对象
  + 减少程序卡顿时间
  + 无法回收循环引用的对象
  + 资源消耗较大
+ 标记清除
  + 可以回收循环引用的对象
  + 容易产生碎片化空间，浪费空间
  + 不会立即回收垃圾对象
+ 标记整理
  + 减少碎片化空间
  + 不会立即回收垃圾对象



## V8

+ V8 是一款主流的 JavaScript 执行引擎
+ V8 采用即时编译
+ V8 内存设限 (64-1.5 32-0.8)



### v8 垃圾回收策略

+ 采用分代回收的思想
+ 内存分为新生代、老生代
+ 针对不同对象采用不同算法



### v8 中常用 GC 算法

+ 分代回收
+ 空间复制
+ 标记清除
+ 标记整理
+ 标记增量



### 新生代对象回收

#### V8 内存分配

+ V8 内存空间一分为二
+ 小空间用于存储新生代对象(32M|16M)
+ 新生代指的是存活时间较短的对象



#### 新生代对象回收实现

+ 回收过程采用复制算法 + 标记整理
+ 新生代内存区分为两个等大小空间
+ 使用空间为 From，空闲空间为 To
+ 活动对象存储于 From 空间
+ 标记整理后将活动对象拷贝至 To
+ From 与 To 交换空间完成释放



#### 回收细节说明

+ 拷贝过程可能出现晋升
+ 晋升就是将新生代对象移动至老生代
+ 一轮 GC 还存活的新生代需要晋升
+ To 空间的使用率超过 25%



### 老生代对象回收

+ 老生代对象存放在右侧老生代区域
+ 内存大小，64 位 1.4G，32位 700M
+ 老生代对象就是值存活时间较长的对象



#### 老生代对象回收实现

+ 主要采用标记清除、标记整理、增量标记算法
+ 首先使用标记清除完成垃圾空间的回收
+ 采用标记整理进行空间优化
+ 采用增量标记进行效率优化



### 细节对比

+ 新生代区域垃圾回收使用空间换时间
+ 老生代区域垃圾回收不适合复制算法



### 总结

+ V8 是一款主流的 JavaScript 执行引擎
+ V8 内存设限 (64-1.5 32-0.8)
+ V8 采用基于分代回收思想实现垃圾回收
+ V8 内存分为新生代和老生代
+ V8 垃圾回收常见的 GC 算法



## Performance

### 为什么使用 Performance

+ GC 的目的是为了实现内存空间的良性循环
+ 良性循环的基石是合理使用
+ 时刻关注才能确定是否合理
+ Performance 提供多种监控方式

通过 Performance 时刻监控内存



### 使用步骤

+ 打开浏览器输入目标网址
+ 进入开发人员工具面板，选择性能
+ 开启录制功能，访问具体界面
+ 执行用户行为，一段时间后停止录制
+ 分析界面中记录的内存信息



### 内存问题的体现

外在表现

+ 页面出现延迟家在或经常性暂停
+ 页面持续性出现糟糕的性能
+ 页面的性能随时间延长越来越差



### 监控内存的几种方式

界定内存问题的标准

+ 内存泄露：内存使用率持续升高
+ 内存膨胀：在多数设备上都存在性能问题
+ 频繁垃圾回收：通过内存变化图进行分析

监控工具

+ 浏览器任务管理器
+ Timeline 时序图记录
+ 堆快照查找分离 DOM
+ 判断是否存在频繁的垃圾回收



### 分离 DOM

DOM 的三种存活状态

+ 界面元素存活在 DOM 树上
+ 垃圾对象时的 DOM 节点
+ 分离状态的 DOM 节点



###  判断是否存在频繁 GC

原因

+ GC 工作时应用程序时停止的
+ 频繁且过长的 GC 会导致应用假死
+ 用户使用着感知应用卡顿

方式

+ TImeline 中频繁的上升下降
+ 任务管理器中数据频繁的增加减小



### 总结

Performance 的使用

+ Performance 使用流程
+ 内存问题的相关分析
+ Performance 时序图监控内存变化
+ 任务管理器监控内存变化
+ 堆快照查找分离 DOM

## 代码优化

### 如何精准测试 JavaScript 性能

+ 本质上就是采集大量的执行样本进行数学统计和分析
+ 使用基于 Benchmark.js 的 https://jsperf.com/ 完成

### Jsperf 使用流程

+ 使用 GitHub 账号登录
+ 填写个人信息（非必须）
+ 填写详细的测试用例信息（title、slug）
+ 填写准备代码（DOM操作时经常使用）
+ 填写必要 setup 与 teardown 代码
+ 填写测试代码片段

### 慎用全局变量

原因

+ 全局变量定义在全局执行上下文，是所有作用域链的顶端
+ 全局执行上下文一直存在于上下文执行栈，直到程序退出
+ 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

![WX20200528-090636@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7w5fsa4qj31jg0pwgoy.jpg)

### 缓存全局变量

将使用中无法避免的全局变量缓存到局部

![WX20200528-092428@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7wlxydgwj31hn0u0agf.jpg)

### 通过原型新增方法

在原型对象上新增实例对象需要的方法

![WX20200528-092944@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7wrc1xkgj31io0qugpl.jpg)

### 避开闭包陷阱

关于闭包

+ 闭包是一种强大的语法
+ 闭包使用不当很容易出现内存泄露
+ 不要为了闭包而闭包

![WX20200528-093429@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7wwd12ldj31j00lsad0.jpg)

### 避免属性访问方法使用

JavaScript 中的面向对象

+ JS 不需属性的访问方法，所有属性都是外部可见的
+ 使用属性访问方法只会增加一层重定义，没有访问的控制力

![WX20200528-093933@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7x1j9tvlj318m0u0tdy.jpg)



### For 循环优化

![WX20200528-094432@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7x6r7uqtj31jo0tcae9.jpg)



### 采用最优循环方式

![WX20200528-094930@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7xbsnwofj31ap0u043l.jpg)

### 节点添加优化

节点的添加操作必然会有回流和重绘

![WX20200528-095609@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7xiqid5fj31j20s8tdi.jpg)

### 克隆优化节点操作

![WX20200528-101124@2x](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7xyotundj31i60pigpr.jpg)

### 直接量替换 Object 操作

![image-20200528102942478](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7yhjxqtyj31i20l0gol.jpg)

